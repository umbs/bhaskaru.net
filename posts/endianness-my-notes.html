<!DOCTYPE html>

<html lang="en">
<head>

<!-- Latest compiled and minified CSS -->
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">

<!-- Optional theme -->
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap-theme.min.css" integrity="sha384-rHyoN1iRsVXV4nD0JutlnGaslCJuC7uwjduW9SVrLvRYooPp2bWYgmgJQIXwl/Sp" crossorigin="anonymous">

<!-- Latest compiled and minified JavaScript -->
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>

</head>


<body>

<h2>
** Endianness – My notes
</h2>

<p>
Consider four byte number: 0x0a0b0c0d; left being smallest memory address and right being highest.
Number: 0x0a0b0c0d. Here LSB is 0x0d and MSB is 0x0a
Memory Address: 0x100    0x101    0x102    0x103
+--------+--------+--------+--------+
|        |        |        |        |
+--------+--------+--------+--------+
</p>

<p>
Little-Endian: In LE, LSB is in lowest memory and MSB in highest memory address. So, the number is stored as: 0x0d0c0b0a in memory.
Ex: Intel x86
Number: 0x0a0b0c0d. Here LSB is 0x0d and MSB is 0x0a
Memory Address: 0x100    0x101    0x102    0x103
+--------+--------+--------+--------+
|  0x0d  |  0x0c  |  0x0b  |  0x0a  |
+--------+--------+--------+--------+
</p>

<p>
code:
int i = 0x0a0b0c0d;
char *c = (char *) &i;
printf ("0x%xn", *c);
// Output is 0xd = little-endian.
</p>

<p>
Big-Endian (aka Network Byte Order): In BE, MSB is in lowest memory address and LSB in highest. It looks the way numbers are written down on paper. So, the number is stored as: 0x0a0b0c0d in memory.
Ex: Motorola 68k, Data transfer on networks use NBO,
Number: 0x0a0b0c0d.
Memory Address: 0x100    0x101    0x102    0x103
+--------+--------+--------+--------+
|  0x0a  |  0x0b  |  0x0c  |  0x0d  |
+--------+--------+--------+--------+
</p>

<p>
code:

int i = 0x0a0b0c0d;
char *c = (char *) &i;
printf ("0x%xn", *c);
// Output is 0xa = big-endian.
</p>

<p>
Host-Byte Order: Ordering on the host machine. If processor is x86, its little-endian, if its Motorola’s 68k, its big-endian.
</p>

<p>
Mixed-Endian (or Middle-Endian): Ordering of bytes within 16-bit word may differ from ordering of 16-bit words within 32-bit word.
</p>

<p>
Bi-Endian: Architectures allowing switchable endianness in data segment, code segment or both. ‘Bi-Endian’ refers how processor accesses data. Instruction access (fetching instruction words) is usually fixed endian. Intel’s Itanium CPU allows bi-endian data and instruction access.
Ex: ARM version 3 and above, PowerPC,
</p>

<p>
Reference:
[1] http://en.wikipedia.org/wiki/Endianness
</p>

</body>
</html>
